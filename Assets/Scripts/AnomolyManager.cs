using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using TMPro;

//creates anomolies and updates the scan circle based on what the player is doing
public class AnomolyManager : MonoBehaviour
{
    [SerializeField] private Transform parentCanvas = null;

    [SerializeField] private Anomoly anomolyPrefab = null;
    [SerializeField] private Transform anomolyParent = null;

    private List<Anomoly> currentAnomolies = new List<Anomoly>();

    [SerializeField] private List<Transform> anomolyTargets = new List<Transform>();

    [SerializeField] private ScanCircle scanCircle = null;

    [SerializeField] private float distanceForTargeting = 20f;

    [SerializeField] private TextMeshProUGUI numPurgedText = null;

    [SerializeField] private Animator numPurgedAnimator = null;

    [SerializeField] private Animator purgeMessageAnimator = null;
    [SerializeField] private TextMeshProUGUI purgeMessageText = null;

    [SerializeField] private float purgeMessageDuration = 3f;

    [SerializeField] private List<string> purgeMessageStrings = new List<string>();

    private int numPurged = 0;

    private bool purgeMessageShowing = false;
    private float currentPurgeMessageDuration = 0f;
    private int purgeMessageIndex = 0;


    public void Update()
    {
        CheckForCreatingAnomolies();
        UpdateScanCircleStatus();
        RunPurgeMessageTimer();
    }

    private void CheckForCreatingAnomolies()
    {
        if (currentAnomolies.Count < 3)
        {
            CreateNewAnomoly();
        }
    }

    private void UpdateScanCircleStatus()
    {
        bool nearTarget = false;
        for (int i = 0; i < currentAnomolies.Count; i++)
        {
            if (Vector2.Distance(scanCircle.transform.position, currentAnomolies[i].transform.position) < distanceForTargeting)
            {
                nearTarget = true;
                break;
            }
        }
        scanCircle.UpdateScanCircleStatus(nearTarget);
    }

    private void RunPurgeMessageTimer()
    {
        if (purgeMessageShowing)
        {
            currentPurgeMessageDuration += Time.deltaTime;
            if (currentPurgeMessageDuration >= purgeMessageDuration)
            {
                currentPurgeMessageDuration = 0f;
                purgeMessageShowing = false;
                purgeMessageAnimator.SetTrigger("Outro");
            }
        }
    }

    private Transform GetAnomolyTarget()
    {
        int randomIndex = Random.Range(0, anomolyTargets.Count);
        return anomolyTargets[randomIndex];
    }

    private void RemoveAnomoly(Anomoly _anomoly, Transform _transform)
    {
        if (currentAnomolies.Contains(_anomoly))
        {
            currentAnomolies.Remove(_anomoly);
        }

        if (!anomolyTargets.Contains(_transform))
        {
            anomolyTargets.Add(_transform);
        }

        Destroy(_anomoly.gameObject);

        numPurged++;
        numPurgedText.text = numPurged.ToString();
        numPurgedAnimator.SetTrigger("Punch");

        SoundManager.Instance.PlayDestroySound();

        ShowPurgeMessage();
    }

    private void CreateNewAnomoly()
    {
        Transform targetTransform = GetAnomolyTarget();
        Anomoly newAnomoly = Instantiate(anomolyPrefab, targetTransform.position, Quaternion.identity, anomolyParent);
        newAnomoly.Init(targetTransform, parentCanvas);
        newAnomoly.OnAnomolyRemoved += RemoveAnomoly;
        newAnomoly.OnStartTakingDamage += ScanCircleDoingDamage;
        newAnomoly.OnStopTakingDamage += ScanCircleStoppedDoingDamage;
        anomolyTargets.Remove(targetTransform);
        currentAnomolies.Add(newAnomoly);
    }

    private void ScanCircleDoingDamage()
    {
        scanCircle.UpdateDamagingStatus(true);
        SoundManager.Instance.PlayChargeSound();
    }

    private void ScanCircleStoppedDoingDamage()
    {
        scanCircle.UpdateDamagingStatus(false);
        SoundManager.Instance.StopChargeSound();
    }

    public void SetScanCircleActive(bool _active)
    {
        scanCircle.gameObject.SetActive(_active);
    }

    private void ShowPurgeMessage()
    {
        purgeMessageAnimator.ResetTrigger("Outro");
        purgeMessageAnimator.SetTrigger("Intro");
        purgeMessageShowing = true;

        //if we've seen all the strings then start over
        if (purgeMessageIndex >= purgeMessageStrings.Count)
        {
            purgeMessageIndex = 0;
        }

        purgeMessageText.text = purgeMessageStrings[purgeMessageIndex];
        purgeMessageIndex++;

    }

}
